import type pkg from '@supabase/supabase-js';
// Ensure 'database.types.ts' (generated by Supabase CLI) exists and
// the path alias '~/' is correctly configured in your tsconfig.json.
// For example, it might be in 'app/types/database.types.ts'
import type { Database } from "../../../database.types"; 
import { DateTime } from "luxon";
import { eq, and, gte, lte } from "drizzle-orm";
// Ensure ONLY IMPORTED from schema.ts - NO LOCAL DEFINITION of StatsCacheInsert or ShareSettingsInsert here.
import { type StatsCacheInsert, type ShareSettingsInsert } from "./schema";
import type { SupabaseClient } from "@supabase/supabase-js";
import type { CategoryCode } from "~/common/types/daily";
import { getUserCategories, getUserDefaultCodePreferences } from "~/features/settings/queries";
import * as planQueries from "~/features/plan/queries";
import type { MonthlyGoalRow as DbMonthlyGoal } from "~/features/plan/queries";
import * as dailyQueries from "~/features/daily/queries";

// Types from database.types.ts used directly
type ShareSettingsTable = Database['public']['Tables']['share_settings'];
type ShareSetting = ShareSettingsTable['Row'];

type StatsCacheTable = Database['public']['Tables']['stats_cache'];

type DailyRecordTable = Database['public']['Tables']['daily_records'];
type DailyRecord = DailyRecordTable['Row'];

// Local type definitions for calculation results (Source of Truth for these)
export interface CategoryDistribution {
  category: CategoryCode;
  count: number;
  duration: number;
  percentage: number;
}

export interface ActivityHeatmap {
  date: string;
  categories: Record<CategoryCode, number>;
  total: number;
  intensity: number;
}

export interface CategorySummary {
  totalRecords: number;
  totalDuration: number;
  averageDuration: number;
  mostActiveDay: string;
  mostActiveTime: string;
}

export interface GoalCompletionStats {
  totalPlans: number;
  completedPlans: number;
  completionRate: number;
  total_goals: number;
  completed_goals: number;
}

// Structure of the 'stats' object stored in the stats_cache table's JSONB columns
export interface StatsCache {
  category_distribution: CategoryDistribution[];
  activity_heatmap?: ActivityHeatmap[] | null;
  weekdayVsWeekend?: { weekday: number, weekend: number };
}

export const getShareSettings = async (
  { profileId, client }: { profileId: string; client: pkg.SupabaseClient<Database> }
): Promise<ShareSetting | null> => {
  const { data, error } = await client
    .from("share_settings")
    .select("*")
    .eq("profile_id", profileId)
    .single();
  if (error && error.code !== 'PGRST116') {
    console.error("Error fetching share settings:", error);
    throw error;
  }
  return data || null;
};

export const upsertShareSettings = async (
  { settingsData, client }: { 
    settingsData: ShareSettingsInsert; // Imported from schema.ts
    client: pkg.SupabaseClient<Database>;
  }
): Promise<ShareSetting> => {
  const { data, error } = await client
    .from("share_settings")
    .upsert(settingsData as any)
    .select()
    .single();
  if (error) {
    console.error("Error upserting share settings:", error);
    throw error;
  }
  if (!data) throw new Error("Upsert operation did not return data for share settings.");
  return data;
};

export const getStatsCache = async (
  client: pkg.SupabaseClient<Database>,
  { profileId, monthDate }: { 
    profileId: string; 
    monthDate: string;
  }
): Promise<StatsCache | null> => {
  const { data, error } = await client
    .from("stats_cache")
    .select("category_distribution, activity_heatmap")
    .eq("profile_id", profileId)
    .eq("month_date", monthDate)
    .single();
  if (error && error.code !== 'PGRST116') {
    console.error("Error fetching stats cache:", error);
    throw error;
  }
  if (!data) return null;
  return {
      category_distribution: data.category_distribution as unknown as CategoryDistribution[],
      activity_heatmap: data.activity_heatmap ? data.activity_heatmap as unknown as ActivityHeatmap[] : null,
  };
};

export const upsertStatsCache = async (
  client: pkg.SupabaseClient<Database>,
  { profileId, monthDate, stats }: { 
    profileId: string; 
    monthDate: string; 
    stats: Omit<StatsCache, 'time_analysis'>;
  }
): Promise<void> => {
  const dataToUpsert: Pick<StatsCacheInsert, 'profile_id' | 'month_date' | 'category_distribution' | 'activity_heatmap'> = { 
      profile_id: profileId,
      month_date: monthDate,
      category_distribution: stats.category_distribution as any,
      activity_heatmap: stats.activity_heatmap ?? null,
  };
  const { error } = await client
    .from("stats_cache")
    .upsert(dataToUpsert as any);
  if (error) {
    console.error("Error upserting stats cache:", error);
    throw error;
  }
};

export const calculateCategoryDistribution = async (
  client: pkg.SupabaseClient<Database>,
  { profileId, startDate, endDate }: { 
    profileId: string; 
    startDate: string; 
    endDate: string;
  }
): Promise<CategoryDistribution[]> => {
  const { data, error } = await client
    .from("daily_records")
    .select("category_code, duration_minutes")
    .eq("profile_id", profileId)
    .gte("date", startDate)
    .lte("date", endDate);

  if (error) {
    console.error("Error in calculateCategoryDistribution:", error);
    throw error;
  }
  if (!data) return [];

  const aggregatedData: { [key: string]: { count: number; duration: number } } = {};
  let totalDurationAll = 0;

  for (const row of data) {
    if (!row.category_code) continue;
    const code = row.category_code as CategoryCode;
    if (!aggregatedData[code]) {
      aggregatedData[code] = { count: 0, duration: 0 };
    }
    aggregatedData[code].count += 1;
    const duration = typeof row.duration_minutes === "number" ? row.duration_minutes : 0;
    aggregatedData[code].duration += duration;
    totalDurationAll += duration;
  }

  const totalCount = data.length;

  return Object.entries(aggregatedData)
    .map(([category, values]) => ({
      category: category as CategoryCode,
      count: values.count,
      duration: values.duration,
      percentage: totalCount > 0 ? Math.round((values.count / totalCount) * 100) : 0,
    }))
    .sort((a, b) => b.count - a.count);
};

export interface YearlyActivity {
  date: string; 
  count: number; 
}

export const getYearlyActivityHeatmapData = async (
  client: pkg.SupabaseClient<Database>,
  { profileId, year }: { profileId: string; year: number }
): Promise<YearlyActivity[]> => {
  const startDateIso = DateTime.fromObject({ year }).startOf("year").toISODate();
  const endDateIso = DateTime.fromObject({ year }).endOf("year").toISODate();
  if (!startDateIso || !endDateIso) {
    throw new Error("Invalid year provided for heatmap data");
  }
  const { data, error } = await client
    .from("daily_records")
    .select("date, count") 
    .eq("profile_id", profileId)
    .gte("date", startDateIso)
    .lte("date", endDateIso)
    .order("date");
  if (error) {
      console.error("Error in getYearlyActivityHeatmapData:", error);
      throw error;
  }
  if (!data) return [];
  const activityByDate: Record<string, number> = {};
  for (const row of data) {
      if (row.date && typeof row.count === 'number') {
          activityByDate[row.date] = (activityByDate[row.date] || 0) + row.count;
      }
  }
  return Object.entries(activityByDate).map(([date, count]) => ({ date, count }));
};

export const calculateActivityHeatmap = async (
  client: pkg.SupabaseClient<Database>,
  { profileId, startDate, endDate }: { 
    profileId: string; 
    startDate: string; 
    endDate: string;
  }
): Promise<ActivityHeatmap[]> => {
  const { data, error } = await client
    .from("daily_records")
    .select("date, category_code, duration_minutes")
    .eq("profile_id", profileId)
    .gte("date", startDate)
    .lte("date", endDate)
    .order("date");
  if (error) {
      console.error("Error in calculateActivityHeatmap:", error);
      throw error;
  }
  if (!data) return [];
  const activityByDate: Record<string, { categories: Record<string, number>; totalIntensityUnits: number }> = {};
  for (const row of data) {
    if (!row.date || !row.category_code) continue;
    const categoryCode = row.category_code as CategoryCode;
    if (!activityByDate[row.date]) {
      activityByDate[row.date] = { categories: {} as Record<CategoryCode, number>, totalIntensityUnits: 0 };
    }
    const intensityUnit = 1;
    activityByDate[row.date].categories[categoryCode] = 
      (activityByDate[row.date].categories[categoryCode] || 0) + intensityUnit;
    activityByDate[row.date].totalIntensityUnits += intensityUnit;
  }
  const maxTotalIntensity = Math.max(...Object.values(activityByDate).map(d => d.totalIntensityUnits), 1); 
  return Object.entries(activityByDate).map(([date, values]) => ({
    date,
    categories: values.categories as Record<CategoryCode, number>,
    total: values.totalIntensityUnits,
    intensity: maxTotalIntensity > 0 ? values.totalIntensityUnits / maxTotalIntensity : 0,
  }));
};

export const searchRecords = async (
  client: pkg.SupabaseClient<Database>,
  { profileId, query, categories }: { 
    profileId: string; 
    query: string;
    categories: string[]; 
  }
): Promise<DailyRecord[]> => {
  let queryBuilder = client
    .from("daily_records")
    .select("*")
    .eq("profile_id", profileId);
  if (query && query.trim() !== "") {
    // Ensuring standard backticks for template literal
    queryBuilder = queryBuilder.ilike("comment", `%${query}%`);
  }
  if (categories && categories.length > 0) {
    queryBuilder = queryBuilder.in("category_code", categories);
  }
  const { data, error } = await queryBuilder.order("date", { ascending: false });
  if (error) {
      console.error("Error in searchRecords:", error);
      throw error;
  }
  return data || [];
};

export const calculateCategorySummary = async (
  client: pkg.SupabaseClient<Database>,
  { profileId, startDate, endDate, categoryCode }: { profileId:string; startDate: string; endDate: string; categoryCode?: CategoryCode }
): Promise<CategorySummary> => {
  let queryBuilder = client
    .from("daily_records")
    .select("date, duration_minutes, created_at")
    .eq("profile_id", profileId)
    .gte("date", startDate)
    .lte("date", endDate);

  if (categoryCode) {
    queryBuilder = queryBuilder.eq("category_code", categoryCode);
  }

  const { data, error } = await queryBuilder;

  if (error) {
    console.error("Error in calculateCategorySummary:", error);
    throw error;
  }
  if (!data || data.length === 0) {
    return {
        totalRecords: 0,
        totalDuration: 0,
        averageDuration: 0,
        mostActiveDay: "없음",
        mostActiveTime: "해당 없음",
    };
  }
  const totalRecords = data.length;
  const totalDuration = data.reduce((sum, row) => sum + (typeof row.duration_minutes === 'number' ? row.duration_minutes : 0), 0);
  const averageDuration = totalRecords > 0 ? totalDuration / totalRecords : 0;
  const activityByDay: Record<string, number> = {};
  for (const row of data) {
      if (row.date) {
        activityByDay[row.date] = (activityByDay[row.date] || 0) + 1;
      }
  }
  const mostActiveDayEntry = Object.entries(activityByDay).length > 0 
    ? Object.entries(activityByDay).sort(([, a], [, b]) => b - a)[0]
    : undefined;
  const mostActiveDay = mostActiveDayEntry ? DateTime.fromISO(mostActiveDayEntry[0]).toFormat("yyyy-MM-dd (ccc)") : "없음";
  return {
    totalRecords,
    totalDuration,
    averageDuration,
    mostActiveDay,
    mostActiveTime: "해당 없음",
  };
};

export interface SummaryInsights {
  mostActiveWeekday: { day: string, count: number } | null;
  weekdayVsWeekend: { weekday: number, weekend: number };
  most_active_category: { category: CategoryCode, count: number } | null;
  longest_duration_category: { category: CategoryCode, duration_minutes: number } | null;
  most_active_time_slot: { time_of_day: 'morning' | 'afternoon' | 'evening' | 'night', count: number } | null;
}

export const calculateSummaryInsights = async (
  client: pkg.SupabaseClient<Database>,
  { profileId, startDate, endDate }: { profileId: string; startDate: string; endDate: string; }
): Promise<SummaryInsights> => {
    const { data, error } = await client
    .from("daily_records")
    .select("date, category_code, duration_minutes")
    .eq("profile_id", profileId)
    .gte("date", startDate)
    .lte("date", endDate);
  
  if (error) {
    console.error("Error fetching data for summary insights:", error);
    throw error;
  }
  if (!data) {
    return {
      mostActiveWeekday: null,
      weekdayVsWeekend: { weekday: 0, weekend: 0 },
      most_active_category: null,
      longest_duration_category: null,
      most_active_time_slot: null,
    };
  }

  const weekdayCounts: { [key: number]: number } = { 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 0 };
  let weekdayRecords = 0;
  let weekendRecords = 0;

  const categoryCounts: Record<string, number> = {};
  const categoryDurations: Record<string, number> = {};
  const timeSlotCounts: Record<'morning' | 'afternoon' | 'evening' | 'night', number> = { morning: 0, afternoon: 0, evening: 0, night: 0 };

  for (const record of data) {
    const dt = DateTime.fromISO(record.date);
    weekdayCounts[dt.weekday]++;
    if (dt.weekday >= 1 && dt.weekday <= 5) {
      weekdayRecords++;
      } else {
      weekendRecords++;
      }

    if (record.category_code) {
        categoryCounts[record.category_code] = (categoryCounts[record.category_code] || 0) + 1;
        categoryDurations[record.category_code] = (categoryDurations[record.category_code] || 0) + (record.duration_minutes || 0);
    }
    
    const hour = dt.hour;
    if (hour >= 6 && hour < 12) timeSlotCounts.morning++;
    else if (hour >= 12 && hour < 18) timeSlotCounts.afternoon++;
    else if (hour >= 18 && hour < 22) timeSlotCounts.evening++;
    else timeSlotCounts.night++;
  }

  const mostActiveWeekdayEntry = Object.entries(weekdayCounts).sort((a, b) => b[1] - a[1])[0];
  const dayNames = ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"];
  
  const mostActiveCategoryEntry = Object.entries(categoryCounts).sort((a,b) => b[1] - a[1])[0];
  const longestDurationCategoryEntry = Object.entries(categoryDurations).sort((a,b) => b[1] - a[1])[0];
  const mostActiveTimeSlotEntry = Object.entries(timeSlotCounts).sort((a,b) => b[1] - a[1])[0];

  return {
    mostActiveWeekday: mostActiveWeekdayEntry && mostActiveWeekdayEntry[1] > 0
      ? { day: dayNames[parseInt(mostActiveWeekdayEntry[0]) - 1], count: mostActiveWeekdayEntry[1] }
      : null,
    weekdayVsWeekend: { weekday: weekdayRecords, weekend: weekendRecords },
    most_active_category: mostActiveCategoryEntry ? { category: mostActiveCategoryEntry[0] as CategoryCode, count: mostActiveCategoryEntry[1] } : null,
    longest_duration_category: longestDurationCategoryEntry ? { category: longestDurationCategoryEntry[0] as CategoryCode, duration_minutes: longestDurationCategoryEntry[1] } : null,
    most_active_time_slot: mostActiveTimeSlotEntry && mostActiveTimeSlotEntry[1] > 0 ? { time_of_day: mostActiveTimeSlotEntry[0] as 'morning' | 'afternoon' | 'evening' | 'night', count: mostActiveTimeSlotEntry[1] } : null,
  };
};

export type TimeOfDayDistribution = {
    time_of_day: "morning" | "afternoon" | "evening" | "night";
    count: number;
    duration_minutes: number;
}[];

export const calculateTimeOfDayDistribution = async (
  client: pkg.SupabaseClient<Database>,
  { profileId, startDate, endDate }: { profileId: string; startDate: string; endDate: string; }
): Promise<TimeOfDayDistribution> => {
  const { data, error } = await client
    .from("daily_records")
    .select("date, duration_minutes")
    .eq("profile_id", profileId)
    .gte("date", startDate)
    .lte("date", endDate);

  if (error) {
    console.error("Error in calculateTimeOfDayDistribution:", error);
    throw error;
  }
    if (!data) return [];

  const distribution: { 
      [key in 'morning' | 'afternoon' | 'evening' | 'night']: { count: number; duration_minutes: number } 
  } = {
    morning: { count: 0, duration_minutes: 0 },
    afternoon: { count: 0, duration_minutes: 0 },
    evening: { count: 0, duration_minutes: 0 },
    night: { count: 0, duration_minutes: 0 },
  };

  for (const record of data) {
    const hour = DateTime.fromISO(record.date).hour;
    const duration = record.duration_minutes || 0;
    if (hour >= 6 && hour < 12) {
      distribution.morning.count++;
      distribution.morning.duration_minutes += duration;
    } else if (hour >= 12 && hour < 18) {
      distribution.afternoon.count++;
      distribution.afternoon.duration_minutes += duration;
    } else if (hour >= 18 && hour < 22) {
      distribution.evening.count++;
      distribution.evening.duration_minutes += duration;
    } else {
      distribution.night.count++;
      distribution.night.duration_minutes += duration;
    }
  }

  return (Object.entries(distribution) as [['morning' | 'afternoon' | 'evening' | 'night', { count: number; duration_minutes: number }]])
    .map(([time_of_day, values]) => ({
        time_of_day,
        ...values
    }))
    .sort((a, b) => { // A fixed order is probably better than sorting by count
        const order = { morning: 1, afternoon: 2, evening: 3, night: 4 };
        return order[a.time_of_day] - order[b.time_of_day];
    });
};

export interface SubcodeDistribution {
  subcode: string;
  count: number;
  duration: number;
  category: CategoryCode;
}

export const calculateSubcodeDistribution = async (
  client: pkg.SupabaseClient<Database>,
  { profileId, startDate, endDate }: { profileId: string; startDate: string; endDate: string; }
): Promise<SubcodeDistribution[]> => {
  const { data, error } = await client
    .from("daily_records")
    .select("subcode, duration_minutes, category_code")
    .eq("profile_id", profileId)
    .gte("date", startDate)
    .lte("date", endDate)
    .not("subcode", "is", null)
    .neq("subcode", "");

  if (error) {
    console.error("Error in calculateSubcodeDistribution:", error);
    throw error;
  }
  if (!data) return [];

  const aggregatedData: { [key: string]: { count: number; duration: number, category: CategoryCode } } = {};

  for (const record of data) {
    if (record.subcode && record.category_code) {
      const key = record.subcode.toLowerCase();
      if (!aggregatedData[key]) {
        aggregatedData[key] = { count: 0, duration: 0, category: record.category_code as CategoryCode };
      }
      aggregatedData[key].count++;
      aggregatedData[key].duration += record.duration_minutes || 0;
    }
  }

  return Object.entries(aggregatedData)
    .map(([subcode, values]) => ({
      subcode,
      ...values,
    }))
    .sort((a, b) => b.count - a.count)
    .slice(0, 15); // Return top 15 subcodes
};

export interface SubcodeDetail {
  subcode: string;
  count: number;
  duration: number;
}

export interface DetailedCategorySummary {
  category_code: CategoryCode;
  total_duration: number;
  total_records: number;
  average_duration: number;
  subcodes: SubcodeDetail[];
}

export async function calculateDetailedCategorySummary(
  client: SupabaseClient,
  { profileId, startDate, endDate }: { profileId: string; startDate: string; endDate: string; }
): Promise<DetailedCategorySummary[]> {
  const { data: records, error } = await client
    .from("daily_records")
    .select("category_code, duration_minutes, subcode")
    .eq("profile_id", profileId)
    .gte("date", startDate)
    .lte("date", endDate);

  if (error) {
    console.error("Error fetching records for detailed summary:", error);
    throw new Error("Failed to fetch records for detailed summary");
  }

  if (!records || records.length === 0) {
    return [];
  }

  const summaryMap: Record<string, {
    total_duration: number;
    total_records: number;
    subcodes: Record<string, { count: number; duration: number }>;
  }> = {};

  for (const record of records) {
    const { category_code, duration_minutes, subcode } = record;
    if (!category_code) continue;

    if (!summaryMap[category_code]) {
      summaryMap[category_code] = {
        total_duration: 0,
        total_records: 0,
        subcodes: {},
      };
    }

    const duration = duration_minutes ?? 0;
    summaryMap[category_code].total_duration += duration;
    summaryMap[category_code].total_records += 1;

    if (subcode) {
      if (!summaryMap[category_code].subcodes[subcode]) {
        summaryMap[category_code].subcodes[subcode] = { count: 0, duration: 0 };
      }
      summaryMap[category_code].subcodes[subcode].count += 1;
      summaryMap[category_code].subcodes[subcode].duration += duration;
    }
  }
  
  return Object.entries(summaryMap).map(([category_code, summary]) => {
    const subcodes: SubcodeDetail[] = Object.entries(summary.subcodes)
      .map(([subcode, details]) => ({
        subcode,
        count: details.count,
        duration: details.duration,
      }))
      .sort((a, b) => b.count - a.count);

    return {
      category_code: category_code as CategoryCode,
      total_duration: summary.total_duration,
      total_records: summary.total_records,
      average_duration: summary.total_records > 0 ? summary.total_duration / summary.total_records : 0,
      subcodes,
    };
  });
}

export const calculateGoalCompletionStats = async (
  client: pkg.SupabaseClient<Database>,
  { profileId, startDate, endDate }: { profileId: string; startDate: string; endDate: string; }
): Promise<GoalCompletionStats> => {
  try {
    const data = await planQueries.getMonthlyGoalsByMonth(client, { profileId, monthDate: startDate });

    if (!data || data.length === 0) {
      return { total_goals: 0, completed_goals: 0, completionRate: 0, totalPlans: 0, completedPlans: 0 };
    }
    const total_goals = data.length;
    const completed_goals = data.filter((g: DbMonthlyGoal) => g.is_completed).length;
    const completionRate = total_goals > 0 ? Math.round((completed_goals / total_goals) * 100) : 0;

    return {
      totalPlans: total_goals,
      completedPlans: completed_goals,
      completionRate,
      total_goals,
      completed_goals,
    };
  } catch (error) {
    console.error("Error fetching monthly goals for stats:", error);
    return { total_goals: 0, completed_goals: 0, completionRate: 0, totalPlans: 0, completedPlans: 0 };
  }
};

export const statsQueries = {
  getShareSettings,
  upsertShareSettings,
  getStatsCache,
  upsertStatsCache,
  calculateCategoryDistribution,
  getYearlyActivityHeatmapData,
  calculateActivityHeatmap,
  searchRecords,
  calculateCategorySummary,
  calculateSummaryInsights,
  calculateTimeOfDayDistribution,
  calculateSubcodeDistribution,
  calculateDetailedCategorySummary,
  calculateGoalCompletionStats,
};

export const settingsQueries = {
  getUserCategories,
  getUserDefaultCodePreferences,
};

export async function getComparisonStats(
  client: SupabaseClient,
  { profileId }: { profileId: string }
) {
    const now = DateTime.now();
    // This month
    const thisMonthStart = now.startOf('month').toISODate();
    // This week
    const thisWeekStart = now.startOf('week').toISODate();
    // Last month
    const lastMonthStart = now.minus({ months: 1 }).startOf('month').toISODate();
    const lastMonthEnd = now.minus({ months: 1 }).endOf('month').toISODate();
    // Last week
    const lastWeekStart = now.minus({ weeks: 1 }).startOf('week').toISODate();
    const lastWeekEnd = now.minus({ weeks: 1 }).endOf('week').toISODate();

    const params = {
        profile_id_in: profileId,
        this_month_start_in: thisMonthStart,
        this_week_start_in: thisWeekStart,
        last_month_start_in: lastMonthStart,
        last_month_end_in: lastMonthEnd,
        last_week_start_in: lastWeekStart,
        last_week_end_in: lastWeekEnd,
    };

  const { data, error } = await client.rpc("get_comparison_stats", params);

  if (error) {
    console.error("Error fetching comparison stats:", error);
    return {
      monthly: { time: { current: 0, prev: 0 }, records: { current: 0, prev: 0 } },
      weekly: { time: { current: 0, prev: 0 }, records: { current: 0, prev: 0 } },
    };
  }

  // Assuming the RPC returns data in the expected nested structure.
  // If the RPC returns a flat structure, this part needs adjustment.
  return {
      monthly: {
          time: { current: data.this_month_duration || 0, prev: data.last_month_duration || 0 },
          records: { current: data.this_month_records || 0, prev: data.last_month_records || 0 },
      },
      weekly: {
          time: { current: data.this_week_duration || 0, prev: data.last_week_duration || 0 },
          records: { current: data.this_week_records || 0, prev: data.last_week_records || 0 },
      }
  };
} 
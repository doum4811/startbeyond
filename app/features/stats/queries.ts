import type pkg from '@supabase/supabase-js';
// Ensure 'database.types.ts' (generated by Supabase CLI) exists and
// the path alias '~/' is correctly configured in your tsconfig.json.
// For example, it might be in 'app/types/database.types.ts'
import type { Database } from "../../../database.types"; 
import { DateTime } from "luxon";
import { eq, and, gte, lte } from "drizzle-orm";
// Ensure ONLY IMPORTED from schema.ts - NO LOCAL DEFINITION of StatsCacheInsert or ShareSettingsInsert here.
import { type StatsCacheInsert, type ShareSettingsInsert } from "./schema";
import type { SupabaseClient } from "@supabase/supabase-js";
import type { CategoryCode } from "~/common/types/daily";
import { getUserCategories, getUserDefaultCodePreferences } from "~/features/settings/queries";
import * as planQueries from "~/features/plan/queries";
import * as dailyQueries from "~/features/daily/queries";

// Types from database.types.ts used directly
type ShareSettingsTable = Database['public']['Tables']['share_settings'];
type ShareSetting = ShareSettingsTable['Row'];

type StatsCacheTable = Database['public']['Tables']['stats_cache'];

type DailyRecordTable = Database['public']['Tables']['daily_records'];
type DailyRecord = DailyRecordTable['Row'];

// Local type definitions for calculation results (Source of Truth for these)
export interface CategoryDistribution {
  category: CategoryCode;
  count: number;
  duration: number;
  percentage: number;
}

export interface ActivityHeatmap {
  date: string;
  categories: Record<CategoryCode, number>;
  total: number;
  intensity: number;
}

export interface CategorySummary {
  totalRecords: number;
  totalDuration: number;
  averageDuration: number;
  mostActiveDay: string;
  mostActiveTime: string;
}

export interface GoalCompletionStats {
  totalPlans: number;
  completedPlans: number;
  completionRate: number;
}

// Structure of the 'stats' object stored in the stats_cache table's JSONB columns
export interface StatsCache {
  category_distribution: CategoryDistribution[];
  activity_heatmap?: ActivityHeatmap[] | null;
}

export const getShareSettings = async (
  { profileId, client }: { profileId: string; client: pkg.SupabaseClient<Database> }
): Promise<ShareSetting | null> => {
  const { data, error } = await client
    .from("share_settings")
    .select("*")
    .eq("profile_id", profileId)
    .single();
  if (error && error.code !== 'PGRST116') {
    console.error("Error fetching share settings:", error);
    throw error;
  }
  return data || null;
};

export const upsertShareSettings = async (
  { settingsData, client }: { 
    settingsData: ShareSettingsInsert; // Imported from schema.ts
    client: pkg.SupabaseClient<Database>;
  }
): Promise<ShareSetting> => {
  const { data, error } = await client
    .from("share_settings")
    .upsert(settingsData as any)
    .select()
    .single();
  if (error) {
    console.error("Error upserting share settings:", error);
    throw error;
  }
  if (!data) throw new Error("Upsert operation did not return data for share settings.");
  return data;
};

export const getStatsCache = async (
  client: pkg.SupabaseClient<Database>,
  { profileId, monthDate }: { 
    profileId: string; 
    monthDate: string;
  }
): Promise<StatsCache | null> => {
  const { data, error } = await client
    .from("stats_cache")
    .select("category_distribution, activity_heatmap")
    .eq("profile_id", profileId)
    .eq("month_date", monthDate)
    .single();
  if (error && error.code !== 'PGRST116') {
    console.error("Error fetching stats cache:", error);
    throw error;
  }
  if (!data) return null;
  return {
      category_distribution: data.category_distribution as unknown as CategoryDistribution[],
      activity_heatmap: data.activity_heatmap ? data.activity_heatmap as unknown as ActivityHeatmap[] : null,
  };
};

export const upsertStatsCache = async (
  client: pkg.SupabaseClient<Database>,
  { profileId, monthDate, stats }: { 
    profileId: string; 
    monthDate: string; 
    stats: Omit<StatsCache, 'time_analysis'>;
  }
): Promise<void> => {
  const dataToUpsert: Pick<StatsCacheInsert, 'profile_id' | 'month_date' | 'category_distribution' | 'activity_heatmap'> = { 
      profile_id: profileId,
      month_date: monthDate,
      category_distribution: stats.category_distribution as any,
      activity_heatmap: stats.activity_heatmap ?? null,
  };
  const { error } = await client
    .from("stats_cache")
    .upsert(dataToUpsert as any);
  if (error) {
    console.error("Error upserting stats cache:", error);
    throw error;
  }
};

export const calculateCategoryDistribution = async (
  client: pkg.SupabaseClient<Database>,
  { profileId, startDate, endDate }: { 
    profileId: string; 
    startDate: string; 
    endDate: string;
  }
): Promise<CategoryDistribution[]> => {
  const { data, error } = await client
    .from("daily_records")
    .select("category_code, duration_minutes")
    .eq("profile_id", profileId)
    .gte("date", startDate)
    .lte("date", endDate);
  if (error) {
      console.error("Error in calculateCategoryDistribution:", error);
      throw error;
  }
  if (!data) return [];
  
  const aggregatedData: { [key: string]: { count: number, duration: number } } = {};
  let totalDurationAll = 0;

  for (const row of data) {
    if (!row.category_code) continue;
    const code = row.category_code as CategoryCode;
    if (!aggregatedData[code]) {
      aggregatedData[code] = { count: 0, duration: 0 };
    }
    aggregatedData[code].count += 1;
    const duration = typeof row.duration_minutes === 'number' ? row.duration_minutes : 0;
    aggregatedData[code].duration += duration;
    totalDurationAll += duration;
  }
  
  const totalCount = data.length;

  return Object.entries(aggregatedData).map(([category, values]) => ({
    category: category as CategoryCode,
    count: values.count,
    duration: values.duration,
    percentage: totalCount > 0 ? Math.round((values.count / totalCount) * 100) : 0,
  })).sort((a,b) => b.count - a.count);
};

export interface YearlyActivity {
  date: string; 
  count: number; 
}

export const getYearlyActivityHeatmapData = async (
  client: pkg.SupabaseClient<Database>,
  { profileId, year }: { profileId: string; year: number }
): Promise<YearlyActivity[]> => {
  const startDateIso = DateTime.fromObject({ year }).startOf("year").toISODate();
  const endDateIso = DateTime.fromObject({ year }).endOf("year").toISODate();
  if (!startDateIso || !endDateIso) {
    throw new Error("Invalid year provided for heatmap data");
  }
  const { data, error } = await client
    .from("daily_records")
    .select("date, count") 
    .eq("profile_id", profileId)
    .gte("date", startDateIso)
    .lte("date", endDateIso)
    .order("date");
  if (error) {
      console.error("Error in getYearlyActivityHeatmapData:", error);
      throw error;
  }
  if (!data) return [];
  const activityByDate: Record<string, number> = {};
  for (const row of data) {
      if (row.date && typeof row.count === 'number') {
          activityByDate[row.date] = (activityByDate[row.date] || 0) + row.count;
      }
  }
  return Object.entries(activityByDate).map(([date, count]) => ({ date, count }));
};

export const calculateActivityHeatmap = async (
  client: pkg.SupabaseClient<Database>,
  { profileId, startDate, endDate }: { 
    profileId: string; 
    startDate: string; 
    endDate: string;
  }
): Promise<ActivityHeatmap[]> => {
  const { data, error } = await client
    .from("daily_records")
    .select("date, category_code, duration_minutes")
    .eq("profile_id", profileId)
    .gte("date", startDate)
    .lte("date", endDate)
    .order("date");
  if (error) {
      console.error("Error in calculateActivityHeatmap:", error);
      throw error;
  }
  if (!data) return [];
  const activityByDate: Record<string, { categories: Record<string, number>; totalIntensityUnits: number }> = {};
  for (const row of data) {
    if (!row.date || !row.category_code) continue;
    const categoryCode = row.category_code as CategoryCode;
    if (!activityByDate[row.date]) {
      activityByDate[row.date] = { categories: {} as Record<CategoryCode, number>, totalIntensityUnits: 0 };
    }
    const intensityUnit = 1;
    activityByDate[row.date].categories[categoryCode] = 
      (activityByDate[row.date].categories[categoryCode] || 0) + intensityUnit;
    activityByDate[row.date].totalIntensityUnits += intensityUnit;
  }
  const maxTotalIntensity = Math.max(...Object.values(activityByDate).map(d => d.totalIntensityUnits), 1); 
  return Object.entries(activityByDate).map(([date, values]) => ({
    date,
    categories: values.categories as Record<CategoryCode, number>,
    total: values.totalIntensityUnits,
    intensity: maxTotalIntensity > 0 ? values.totalIntensityUnits / maxTotalIntensity : 0,
  }));
};

export const searchRecords = async (
  client: pkg.SupabaseClient<Database>,
  { profileId, query, categories }: { 
    profileId: string; 
    query: string;
    categories: string[]; 
  }
): Promise<DailyRecord[]> => {
  let queryBuilder = client
    .from("daily_records")
    .select("*")
    .eq("profile_id", profileId);
  if (query && query.trim() !== "") {
    // Ensuring standard backticks for template literal
    queryBuilder = queryBuilder.ilike("comment", `%${query}%`);
  }
  if (categories && categories.length > 0) {
    queryBuilder = queryBuilder.in("category_code", categories);
  }
  const { data, error } = await queryBuilder.order("date", { ascending: false });
  if (error) {
      console.error("Error in searchRecords:", error);
      throw error;
  }
  return data || [];
};

export const calculateCategorySummary = async (
  client: pkg.SupabaseClient<Database>,
  { profileId, startDate, endDate, categoryCode }: { profileId:string; startDate: string; endDate: string; categoryCode?: CategoryCode }
): Promise<CategorySummary> => {
  let queryBuilder = client
    .from("daily_records")
    .select("date, duration_minutes, created_at")
    .eq("profile_id", profileId)
    .gte("date", startDate)
    .lte("date", endDate);

  if (categoryCode) {
    queryBuilder = queryBuilder.eq("category_code", categoryCode);
  }

  const { data, error } = await queryBuilder;

  if (error) {
    console.error("Error in calculateCategorySummary:", error);
    throw error;
  }
  if (!data || data.length === 0) {
    return {
        totalRecords: 0,
        totalDuration: 0,
        averageDuration: 0,
        mostActiveDay: "없음",
        mostActiveTime: "해당 없음",
    };
  }
  const totalRecords = data.length;
  const totalDuration = data.reduce((sum, row) => sum + (typeof row.duration_minutes === 'number' ? row.duration_minutes : 0), 0);
  const averageDuration = totalRecords > 0 ? totalDuration / totalRecords : 0;
  const activityByDay: Record<string, number> = {};
  for (const row of data) {
      if (row.date) {
        activityByDay[row.date] = (activityByDay[row.date] || 0) + 1;
      }
  }
  const mostActiveDayEntry = Object.entries(activityByDay).length > 0 
    ? Object.entries(activityByDay).sort(([, a], [, b]) => b - a)[0]
    : undefined;
  const mostActiveDay = mostActiveDayEntry ? DateTime.fromISO(mostActiveDayEntry[0]).toFormat("yyyy-MM-dd (ccc)") : "없음";
  return {
    totalRecords,
    totalDuration,
    averageDuration,
    mostActiveDay,
    mostActiveTime: "해당 없음",
  };
};

export interface SummaryInsights {
  mostActiveWeekday: { day: string, count: number } | null;
  weekdayVsWeekend: { weekday: number, weekend: number };
}

export const calculateSummaryInsights = async (
  client: pkg.SupabaseClient<Database>,
  { profileId, startDate, endDate }: { profileId: string; startDate: string; endDate: string; }
): Promise<SummaryInsights> => {
    const { data, error } = await client
    .from("daily_records")
    .select("date")
    .eq("profile_id", profileId)
    .gte("date", startDate)
    .lte("date", endDate);
  
  if (error) {
    console.error("Error in calculateSummaryInsights:", error);
    throw error;
  }
  
  if (!data || data.length === 0) {
    return {
      mostActiveWeekday: null,
      weekdayVsWeekend: { weekday: 0, weekend: 0 },
    };
  }

  const weekdayCounts: Record<number, number> = { 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 0 };
  const weekdayLabels: Record<number, string> = { 1: "월요일", 2: "화요일", 3: "수요일", 4: "목요일", 5: "금요일", 6: "토요일", 7: "일요일" };
  let weekdayTotal = 0;
  let weekendTotal = 0;

  for (const record of data) {
    const dt = DateTime.fromISO(record.date);
    if(dt.isValid) {
      const weekday = dt.weekday; // Luxon: 1 for Mon, 7 for Sun
      weekdayCounts[weekday]++;
      if (weekday >= 1 && weekday <= 5) {
        weekdayTotal++;
      } else {
        weekendTotal++;
      }
    }
  }

  const mostActiveDayEntry = Object.entries(weekdayCounts)
    .filter(([, count]) => count > 0)
    .sort((a, b) => b[1] - a[1])[0];

  const mostActiveWeekday = mostActiveDayEntry 
    ? { day: weekdayLabels[parseInt(mostActiveDayEntry[0])], count: mostActiveDayEntry[1] } 
    : null;

  return {
    mostActiveWeekday,
    weekdayVsWeekend: { weekday: weekdayTotal, weekend: weekendTotal },
  };
};

export interface TimeOfDayDistribution {
  morning: number;
  afternoon: number;
  evening: number;
  night: number;
}

export const calculateTimeOfDayDistribution = async (
  client: pkg.SupabaseClient<Database>,
  { profileId, startDate, endDate }: { profileId: string; startDate: string; endDate: string; }
): Promise<TimeOfDayDistribution> => {
  const { data, error } = await client
    .from("daily_records")
    .select("created_at")
    .eq("profile_id", profileId)
    .gte("date", startDate)
    .lte("date", endDate);

  if (error) {
    console.error("Error in calculateTimeOfDayDistribution:", error);
    throw error;
  }

  const distribution: TimeOfDayDistribution = { morning: 0, afternoon: 0, evening: 0, night: 0 };
  if (!data) return distribution;

  for (const record of data) {
    if (record.created_at) {
      const hour = DateTime.fromISO(record.created_at).hour;
      if (hour >= 5 && hour < 12) distribution.morning++;
      else if (hour >= 12 && hour < 17) distribution.afternoon++;
      else if (hour >= 17 && hour < 21) distribution.evening++;
      else distribution.night++;
    }
  }

  return distribution;
}

export interface SubcodeDistribution {
  subcode: string;
  count: number;
  duration: number;
  category: CategoryCode;
}

export const calculateSubcodeDistribution = async (
  client: pkg.SupabaseClient<Database>,
  { profileId, startDate, endDate }: { profileId: string; startDate: string; endDate: string; }
): Promise<SubcodeDistribution[]> => {
  const { data, error } = await client
    .from("daily_records")
    .select("subcode, duration_minutes, category_code")
    .eq("profile_id", profileId)
    .gte("date", startDate)
    .lte("date", endDate)
    .not("subcode", "is", null)
    .neq("subcode", "");

  if (error) {
    console.error("Error in calculateSubcodeDistribution:", error);
    throw error;
  }
  if (!data) return [];

  const aggregatedData: { [key: string]: { count: number; duration: number, category: CategoryCode } } = {};

  for (const record of data) {
    if (record.subcode && record.category_code) {
      const key = record.subcode.toLowerCase();
      if (!aggregatedData[key]) {
        aggregatedData[key] = { count: 0, duration: 0, category: record.category_code as CategoryCode };
      }
      aggregatedData[key].count++;
      aggregatedData[key].duration += record.duration_minutes || 0;
    }
  }

  return Object.entries(aggregatedData)
    .map(([subcode, values]) => ({
      subcode,
      ...values,
    }))
    .sort((a, b) => b.count - a.count)
    .slice(0, 15); // Return top 15 subcodes
};

export interface SubcodeDetail {
  subcode: string;
  count: number;
  duration: number;
}

export interface DetailedCategorySummary {
  category_code: CategoryCode;
  total_duration: number;
  total_records: number;
  average_duration: number;
  subcodes: SubcodeDetail[];
}

export const calculateDetailedCategorySummary = async (
  client: pkg.SupabaseClient<Database>,
  { profileId, startDate, endDate }: { profileId: string; startDate: string; endDate: string; }
): Promise<DetailedCategorySummary[]> => {
  const { data: records, error } = await client
    .from("daily_records")
    .select("category_code, duration_minutes, subcode")
    .eq("profile_id", profileId)
    .gte("date", startDate)
    .lte("date", endDate);

  if (error) {
    console.error("Error fetching records for detailed summary:", error);
    throw new Error("Failed to fetch records for detailed summary");
  }

  if (!records || records.length === 0) {
    return [];
  }

  const summaryMap: Record<string, {
    total_duration: number;
    total_records: number;
    subcodes: Record<string, { count: number; duration: number }>;
  }> = {};

  for (const record of records) {
    const { category_code, duration_minutes, subcode } = record;
    if (!category_code) continue;

    if (!summaryMap[category_code]) {
      summaryMap[category_code] = {
        total_duration: 0,
        total_records: 0,
        subcodes: {},
      };
    }

    const duration = duration_minutes ?? 0;
    summaryMap[category_code].total_duration += duration;
    summaryMap[category_code].total_records += 1;

    if (subcode) {
      if (!summaryMap[category_code].subcodes[subcode]) {
        summaryMap[category_code].subcodes[subcode] = { count: 0, duration: 0 };
      }
      summaryMap[category_code].subcodes[subcode].count += 1;
      summaryMap[category_code].subcodes[subcode].duration += duration;
    }
  }
  
  return Object.entries(summaryMap).map(([category_code, summary]) => {
    const subcodes: SubcodeDetail[] = Object.entries(summary.subcodes)
      .map(([subcode, details]) => ({
        subcode,
        count: details.count,
        duration: details.duration,
      }))
      .sort((a, b) => b.count - a.count);

    return {
      category_code: category_code as CategoryCode,
      total_duration: summary.total_duration,
      total_records: summary.total_records,
      average_duration: summary.total_records > 0 ? summary.total_duration / summary.total_records : 0,
      subcodes,
    };
  });
};

export const calculateGoalCompletionStats = async (
  client: pkg.SupabaseClient<Database>,
  { profileId, startDate, endDate }: { profileId: string; startDate: string; endDate: string; }
): Promise<GoalCompletionStats> => {
  const [plans, records] = await Promise.all([
    planQueries.getDailyPlansByPeriod(client, { profileId, startDate, endDate }),
    dailyQueries.getDailyRecordsByPeriod(client, { profileId, startDate, endDate }),
  ]);

  if (!plans || plans.length === 0) {
    return { totalPlans: 0, completedPlans: 0, completionRate: 0 };
  }

  const completedPlanIds = new Set(records.map(r => r.linked_plan_id).filter((id): id is string => !!id));

  const totalPlans = plans.length;
  const completedPlansInPeriod = plans.filter(p => completedPlanIds.has(p.id)).length;

  const completionRate = totalPlans > 0 ? Math.round((completedPlansInPeriod / totalPlans) * 100) : 0;

  return { totalPlans, completedPlans: completedPlansInPeriod, completionRate };
};

export const statsQueries = {
  getShareSettings,
  upsertShareSettings,
  getStatsCache,
  upsertStatsCache,
  calculateCategoryDistribution,
  getYearlyActivityHeatmapData,
  calculateActivityHeatmap,
  searchRecords,
  calculateCategorySummary,
  calculateSummaryInsights,
  calculateTimeOfDayDistribution,
  calculateSubcodeDistribution,
  calculateDetailedCategorySummary,
  calculateGoalCompletionStats,
};

export const settingsQueries = {
  getUserCategories,
  getUserDefaultCodePreferences,
}; 
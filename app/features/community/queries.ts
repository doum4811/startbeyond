import client from "~/supa-client";
import type { Database } from "database.types";
import type { communityPosts, communityComments } from "./schema"; // Assuming schema exports these table types

// Types from database.types.ts or generated by Drizzle
export type CommunityPostTable = Database['public']['Tables']['community_posts'];
export type CommunityPost = CommunityPostTable['Row'];
export type CommunityPostInsert = CommunityPostTable['Insert'];

export type CommunityCommentTable = Database['public']['Tables']['community_comments'];
export type CommunityComment = CommunityCommentTable['Row'];
export type CommunityCommentInsert = CommunityCommentTable['Insert'];


const COMMUNITY_POST_COLUMNS = `
  id,
  profile_id,
  title,
  content,
  category,
  created_at,
  updated_at
`;

// We'll need profile information too, so let's define a type for post with author
export interface CommunityPostWithAuthor extends CommunityPost {
  author_name: string | null; // Or a more detailed profile type
  author_avatar_url: string | null;
}


const COMMUNITY_COMMENT_COLUMNS = `
  id,
  post_id,
  profile_id,
  content,
  created_at,
  updated_at
`;

export interface CommunityCommentWithAuthor extends CommunityComment {
  author_name: string | null;
  author_avatar_url: string | null;
}

// == Community Posts ==

export async function getCommunityPosts(
  { limit = 20, offset = 0 }: { limit?: number; offset?: number }
): Promise<CommunityPostWithAuthor[]> {
  const { data, error } = await client
    .from("community_posts")
    .select(`
      ${COMMUNITY_POST_COLUMNS},
      profiles (
        username,
        avatar_url
      )
    `)
    .order("created_at", { ascending: false })
    .range(offset, offset + limit - 1);

  if (error) {
    console.error("Error fetching community posts:", error.message);
    throw new Error(error.message);
  }
  return (data || []).map(post => ({
    ...(post as CommunityPost),
    author_name: post.profiles?.username || 'Unknown User',
    author_avatar_url: post.profiles?.avatar_url || null,
  }));
}

export async function getCommunityPostById(
  { postId }: { postId: string }
): Promise<CommunityPostWithAuthor | null> {
  const { data, error } = await client
    .from("community_posts")
    .select(`
      ${COMMUNITY_POST_COLUMNS},
      profiles (
        username,
        avatar_url
      )
    `)
    .eq("id", postId)
    .single();

  if (error) {
    if (error.code === 'PGRST116') return null; // Not found
    console.error("Error fetching community post by ID:", error.message);
    throw new Error(error.message);
  }
  if (!data) return null;
  return {
    ...(data as CommunityPost),
    author_name: data.profiles?.username || 'Unknown User',
    author_avatar_url: data.profiles?.avatar_url || null,
  };
}


export async function createCommunityPost(
  postData: CommunityPostInsert
): Promise<CommunityPost | null> {
  const { data, error } = await client
    .from("community_posts")
    .insert(postData)
    .select(COMMUNITY_POST_COLUMNS)
    .single();

  if (error) {
    console.error("Error creating community post:", error.message);
    throw new Error(error.message);
  }
  return data;
}

export async function updateCommunityPost(
  { postId, profileId, updates }: { postId: string; profileId: string; updates: Partial<Omit<CommunityPostInsert, "id" | "profile_id" | "created_at">> }
): Promise<CommunityPost | null> {
  const { data, error } = await client
    .from("community_posts")
    .update(updates)
    .eq("id", postId)
    .eq("profile_id", profileId) // Ensure only owner can update
    .select(COMMUNITY_POST_COLUMNS)
    .single();

  if (error) {
    console.error("Error updating community post:", error.message);
    throw new Error(error.message);
  }
  return data;
}

export async function deleteCommunityPost(
  { postId, profileId }: { postId: string; profileId: string }
): Promise<boolean> {
  const { error } = await client
    .from("community_posts")
    .delete()
    .eq("id", postId)
    .eq("profile_id", profileId); // Ensure only owner can delete

  if (error) {
    console.error("Error deleting community post:", error.message);
    throw new Error(error.message);
  }
  return true;
}


// == Community Comments ==

export async function getCommentsByPostId(
  { postId, limit = 20, offset = 0 }: { postId: string; limit?: number; offset?: number }
): Promise<CommunityCommentWithAuthor[]> {
  const { data, error } = await client
    .from("community_comments")
    .select(`
      ${COMMUNITY_COMMENT_COLUMNS},
      profiles (
        username,
        avatar_url
      )
    `)
    .eq("post_id", postId)
    .order("created_at", { ascending: true })
    .range(offset, offset + limit - 1);

  if (error) {
    console.error("Error fetching comments for post:", error.message);
    throw new Error(error.message);
  }
  return (data || []).map(comment => ({
    ...(comment as CommunityComment),
    author_name: comment.profiles?.username || 'Unknown User',
    author_avatar_url: comment.profiles?.avatar_url || null,
  }));
}

export async function createCommunityComment(
  commentData: CommunityCommentInsert
): Promise<CommunityComment | null> {
  const { data, error } = await client
    .from("community_comments")
    .insert(commentData)
    .select(COMMUNITY_COMMENT_COLUMNS)
    .single();

  if (error) {
    console.error("Error creating community comment:", error.message);
    throw new Error(error.message);
  }
  return data;
}

export async function deleteCommunityComment(
  { commentId, profileId }: { commentId: string; profileId: string }
): Promise<boolean> {
  // Add logic to check if user is comment owner or post owner for deletion permissions
  const { error } = await client
    .from("community_comments")
    .delete()
    .eq("id", commentId)
    .eq("profile_id", profileId); // Ensure only comment owner can delete (or post owner - more complex query)

  if (error) {
    console.error("Error deleting community comment:", error.message);
    throw new Error(error.message);
  }
  return true;
} 